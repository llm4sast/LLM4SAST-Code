from utils.config import LLM_MODEL

from model.LLM import LLMModel
from langchain.prompts import PromptTemplate

# system_prompt = '''You are a testing expert, and you will mutate input programs for testing static application security testing (SAST) tools. Your task is to construct variant programs that can trigger crash, false positive, or false negative bugs in Rust SAST tools like lockbud, rudra, and Prusti.'''
# system_prompt = '''You are a testing expert, and your task is mutating input programs for testing static application security testing (SAST) tools and constructing variant programs that can trigger crash, false positive, or false negative bugs in Java SAST tools like PMD, Infer, SpotBugs.'''
system_prompt = '''You are a testing expert, and your task is transforming input programs for testing static application
security testing (SAST) tools and constructing program variants that can trigger faults.'''


llm_query = LLMModel(model_name=LLM_MODEL, system_message=system_prompt)

# few-shots learning for oracle 1
# oracle1_prompt = '''The code of input program:
# {input_program}
# Its analysis report generated by {tool} is: {report}. This report identifies the locations and types of potential bugs in the input program. Please locate the code segments associated with the bug, use program slicing to identify the relevant program elements and perform semantics-preserving transformations ensuring that the program behavior and the number of {bug_type} warnings in the analysis report remain unchanged. For example, two such transformations could be replacing a library API with an equivalent API and injecting dead code. Generate mutants by applying various semantics-preserving transformations to ensure diversity. Whenever possible, maximize the use of new programming language features. As your goal is to find crash, FN, or FP bugs, I give you the document of {bug_type} in {tool} for understanding and constructing mutants to trigger bugs: {bug_description} You must only give me the source code of transformed programs, not add comments and new line breaks. Separate the adjacent mutants with a divider composed of three equal signs.'''

# one-shot learning for oracle 1
# oracle1_prompt = '''The code of input program:
# ```java
# {input_program}
# ```
# Its analysis report generated by {tool} is: {report}.
# The report identifies locations and types of potential bugs in the input program. Please locate the segments related to the bug, use program slicing to identify the relevant program elements and perform semantics-preserving transformations ensuring that the program behavior and the number of {bug_type} warnings in the analysis report remain unchanged, e.g., replacing a library API with an equivalent one. Generate mutants by applying various semantics-preserving transformations to ensure diversity. Whenever possible, maximize the use of new programming language features. As your goal is to find crash, FN, or FP bugs, I give you the document of {bug_type} in {tool} for understanding: {bug_description} Avoid introducing code that triggers additional warnings of this type. You must only give me the source code of transformed programs, not add comments and new line breaks. Separate the adjacent mutants with a divider composed of three equal signs.'''

# # zero-shot learning for oracle 1
# oracle1_prompt = '''The code of input program:
# ```java
# {input_program}
# ```
# Its analysis report generated by {tool} is: {report}.
# The report identifies locations and types of potential bugs in the input program. Please locate the segments related to the bug, use program slicing to identify the relevant program elements and perform semantics-preserving transformations ensuring that the program behavior and the number of {bug_type} warnings in the analysis report remain unchanged. Generate mutants by applying various semantics-preserving transformations to ensure diversity. Whenever possible, maximize the use of new programming language features. As your goal is to find crash, FN, or FP bugs, I give you the document of {bug_type} in {tool} for understanding: {bug_description} Avoid introducing code that triggers additional warnings of this type. You must only give me the source code of transformed programs, not add comments and new line breaks. Separate the adjacent mutants with a divider composed of three equal signs.'''


oracle1_prompt = """
[Function Instructions]:
1. Understand the {bug_type} vulnerability by cross-referencing its document:
{bug_description};
2. Leverage the analysis report to both locate the vulnerability and comprehend its root cause, use program slicing to identify the relevant program elements;
3. Perform varied semantics-preserving transformations on these elements to produce diverse variants. Each transformation must preserve both the original program behavior and the reported count of {bug_type} warnings in the analysis report.
[Output Instructions]
The output must be source code of transformed programs, not add comments and new line breaks
[Input]
Here are the contents of the analysis report: {document} and input program {code}."""

oracle1_prompt_template = PromptTemplate(
    input_variables=["code", "tool", "document", "bug_type", "bug_description", "mutant_cnt"],
    template=oracle1_prompt
)

# # repair oracle
# oracle2_prompt = '''First, let me show you the document of {bug_type} bug: {bug_document}
# Then, the following input program contains the {bug_type} bug:
# {input_program}
# Its analysis report generated by {tool} is: {report}.
# The report identifies locations and types of potential bugs in the input program. Your task is to locate a {bug_type} bug via the report, fix it using diverse approaches, and provide the fixed programs, ensuring diversity, e.g., to repair double-locks, always release the first lock before obtaining a second lock on the same resource. Provide as many distinct repaired programs as possible. You must only give me the source code of transformed programs, not add comments and new line breaks. Separate the adjacent mutants with a divider composed of three equal signs.'''

oracle2_prompt = """
[Function Instructions]:
1. Understand the {bug_type} vulnerability by cross-referencing its document:
{bug_document};
2. Leverage the analysis report to both locate the vulnerability and comprehend its root cause;
3. Fix it using diverse approaches, and provide the fixed programs, ensuring diversity, and use the provided reference pair {buggy_program} and {fixed_program} to confirm your understanding of the pattern and a standard fix method for the vulnerability.
[Output Instructions]
The output must be source code of transformed programs, not add comments and new line breaks
[Input]
Here are the contents of the analysis report: {report} and input program {input_program}.
"""

oracle2_prompt_template = PromptTemplate(
    input_variables=["bug_type", "bug_document", "buggy_program", "fixed_program", "input_program", "tool", "report"],
    template=oracle2_prompt
)

# # injection oracle
# oracle3_prompt = '''Give you the description of {bug_type} bug: {bug_doc} The following input program contains the {bug_type} bug:
# {input_program}
# Its analysis report generated by {tool} is: {report}.
# The report indicates one {bug_type} bug in the input program. Understand the root cause of this bug, and your task is to inject new {bug_type} bugs while preserving existing code and ensuring diverse injection approaches. Provide as many distinct, compilable, and vulnerability-injected programs as possible. You must only give me the source code of transformed programs without adding new comments and line breaks. Separate the adjacent mutants with a divider composed of three equal signs.'''

oracle3_prompt = """
[Function Instructions]:
1. Understand the {bug_type} vulnerability by cross-referencing its document:
{bug_document};
2. Leverage the analysis report to both locate the vulnerability and comprehend its root cause;
3. Inject a new instance of this vulnerability type through diverse implementation approaches, while
ensuring variation across the generated programs;
4. Learn the injection process by comparing against the provided reference pair: {buggy_program} and
{injected_program}.
[Output Instructions]
The output must be source code of transformed programs, not add comments and new line breaks
[Input]
Here are the contents of the analysis report: {report} and input program {input_program}.
"""

oracle3_prompt_template = PromptTemplate(
    input_variables=["bug_type", "tool", "bug_document", "buggy_program", "injected_program", "input_program", "report"],
    template=oracle3_prompt)

fix_prompt = '''You provide me a test program in previous chat:
{generated_code}
However, it has the following compilation errors:
{compilation_error}
Please fix them and give me a correctly compliable program.
'''

# fix_loop_prompt = '''You try to fix a test program previously:
# {generated_code}
# and the fixed program is:
# {fixed_code}
# However, it still has the following compilation errors:
# {compilation_error}
# '''

fix_loop_prompt = """
[Function Instructions]
1. You provide me a program variant previously: {generated_code}
2. However, it has the following compilation errors: {compilation_error}
3. Please fix them and give me a correctly compilable program.
"""

repair_prompt_template = PromptTemplate(
    input_variables=["generated_code", "compilation_error"],
    template=fix_loop_prompt)