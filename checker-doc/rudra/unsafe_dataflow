Unsafe Dataflow includes two sub-checkers: (1) Panic Safety (Unsafe code that can create memory-safety issues when panicked)
Detects when unsafe code may lead to memory safety issues if a user provided closure or trait panics. For example, consider a function that dereferences a pointer with ptr::read, duplicating its ownership and then calls a user provided function f. This can lead to a double-free if the function f panics; (2) Higher-order Safety Invariant. A Rust function should execute safely for all safe inputs; from the data types of its arguments, generic type parameters as well as user-provided closures. In other words, a safe function is not allowed to assume anything more than the safety invariants provided by the Rust compiler. For example, the sort function in Rust must not trigger any undefined behavior even when a user-provided comparator does not respect total ordering, unlike the sort function in C++ that can cause a segmentation fault with an incompatible comparator.
